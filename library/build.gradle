import com.github.spotbugs.SpotBugsTask
import groovy.io.FileType
import groovy.text.SimpleTemplateEngine
import net.ltgt.gradle.errorprone.javacplugin.CheckSeverity

import java.nio.file.Files
import java.util.regex.Pattern

apply plugin: 'java-library'
apply plugin: 'maven-publish'

apply plugin: 'net.ltgt.errorprone-javacplugin'
apply plugin: 'com.github.spotbugs'
apply plugin: 'checkstyle'
apply plugin: 'jacoco'
apply plugin: 'pmd'

apply plugin: 'com.github.ben-manes.versions'
apply plugin: 'de.fuerstenau.buildconfig'

apply plugin: 'idea'

sourceCompatibility = JavaVersion.VERSION_1_8
targetCompatibility = JavaVersion.VERSION_1_8

dependencies {
    errorprone deps.errorprone

    annotationProcessor deps.lombok
    api deps.lombok

    // Changed later to provided.
    api deps.javaxExtras
    api deps.jsr305

    api deps.retrofit
    api deps.retrofitMoshi
    api deps.okHttp
    api deps.moshi
    api deps.moshiLazyAdapters

    testAnnotationProcessor deps.lombok
    testCompileOnly deps.lombok

    testImplementation deps.junitApi
    testImplementation deps.assertj
    testImplementation deps.mockito
    testImplementation deps.okhttpTls
    testImplementation deps.mockwebserver
    testImplementation deps.privateConstructor

    testRuntime deps.junitEngine
}

task generatePackageInfo {
    File generatedPackageInfoDir = file("$buildDir/generated")

    sourceSets.main.java.srcDirs -= generatedPackageInfoDir
    sourceSets.main.java.srcDirs.each { inputs.dir(it.absolutePath) }
    outputs.dir(generatedPackageInfoDir)

    sourceSets.main.java.srcDirs += generatedPackageInfoDir

    doLast {
        Pattern packagePattern = Pattern.compile('package (.*?);', Pattern.DOTALL)
        String templateText = new File(projectDir, 'package-info.template').text
        Set<String> packages = []

        generatedPackageInfoDir.deleteDir()
        generatedPackageInfoDir.mkdirs()

        sourceSets.main.java.srcDirs.each {
            it.eachFileRecurse(FileType.FILES) {
                if (it.name.endsWith('.java')) {
                    Files.lines(it.toPath())
                            .map { line -> packagePattern.matcher(line) }
                            .filter { matcher -> matcher.matches() }
                            .findFirst()
                            .ifPresent { matcher -> packages += matcher.group(1) }
                }
            }
        }

        packages.each {
            File outputDirectory = mkdir(new File(generatedPackageInfoDir, it.replaceAll('\\.', '/')))
            File outputFile = new File(outputDirectory.absolutePath, 'package-info.java')

            String templateOutput = new SimpleTemplateEngine()
                    .createTemplate(templateText)
                    .make(['packageName': it])
                    .toString()

            outputFile << templateOutput
        }
    }
}

task delombok(type: JavaExec, dependsOn: compileJava) {
    String buildConfigInputDir = "$buildDir/gen/buildconfig/src/main"

    ext.outputDir = 'build/delombok'
    outputs.dir(outputDir)
    inputs.dir(buildConfigInputDir)

    args += "delombok"

    sourceSets.main.java.srcDirs.each {
        inputs.dir(it)

        args += it
    }

    args += buildConfigInputDir
    args += "--target=$outputDir"
    args += "--classpath=$configurations.compileClasspath.asPath"

    classpath configurations.compileOnly.asPath
    main = "lombok.launch.Main"
}

task sourceJar(type: Jar, dependsOn: delombok) {
    from delombok.outputDir
}

task javadocJar(type: Jar, dependsOn: javadoc) {
    from javadoc.destinationDir
}

buildConfig {
    packageName = 'me.proxer.library'
    version = project.version
}

javadoc {
    dependsOn delombok

    failOnError = false
    source = delombok.outputDir

    options.memberLevel = JavadocMemberLevel.PUBLIC
    options.addBooleanOption('Xdoclint:-missing', true)
}

jacoco {
    setToolVersion(jacocoVersion)
}

jacocoTestReport {
    reports {
        xml.enabled = true
        html.enabled = false
    }
}

checkstyle {
    setToolVersion(checkstyleVersion)
}

spotbugs {
    setToolVersion(spotbugsVersion)

    excludeFilter = rootProject.file('config/spotbugs/spotbugs-filter.xml')
}

tasks.withType(SpotBugsTask) {
    reports {
        xml.enabled = false
        html.enabled = true
    }
}

pmd {
    ruleSetFiles = rootProject.files("config/pmd/pmd-rulesets.xml")
    ruleSets = []

    setToolVersion(pmdVersion)
}

tasks.withType(FindBugs) {
    reports {
        xml.enabled = false
        html.enabled = true
    }
}

publishing {
    publications {
        mavenJava(MavenPublication) {
            artifactId = 'ProxerLibJava'

            from components.java

            artifact sourceJar {
                classifier "sources"
            }

            artifact javadocJar {
                classifier "javadoc"
            }

            pom {
                name = 'ProxerLibJava'
                description = 'An Java and Android library, implementing the API of the Proxer.me website'
                url = 'https://github.com/proxer/ProxerLibJava'

                scm {
                    url = 'https://github.com/proxer/ProxerLibJava'
                    connection = 'scm:git:https://github.com/proxer/ProxerLibJava'
                    developerConnection = 'scm:git:git@github.com/proxer/ProxerLibJava'
                    tag = 'HEAD'
                }

                issueManagement {
                    system = 'GitHub Issues'
                    url = 'https://github.com/proxer/ProxerLibJava/issues'
                }

                licenses {
                    license {
                        name = 'MIT'
                        url = 'https://opensource.org/licenses/MIT'
                        distribution = 'repo'
                    }
                }
            }

            pom.withXml {
                asNode().dependencies.'*'
                        .findAll() { it.artifactId.text() == "jsr305" || it.artifactId.text() == "javax-extras" }
                        .each { it.scope*.value = 'provided' }
            }
        }
    }
}

afterEvaluate {
    tasks.withType(JavaCompile) {
        options.compilerArgs << "-Werror"
        options.encoding = 'UTF-8'

        // Something seems to add a JavaCompile type task which does not has the errorprone property.
        if (options.hasProperty("errorprone")) {
            options.errorprone {
                disableWarningsInGeneratedCode = true

                check("ParameterName", CheckSeverity.OFF)
            }
        }
    }

    compileJava.dependsOn(generatePackageInfo)
    test { finalizedBy jacocoTestReport }
}
